# Регулярные выражения

На поиск влияют три сущности:

> Спецсимволы — содержатся в самóм регулярном выражении и позволяют тоньше задать поиск. Например, искать в тексте сразу «Яндекс» и «Yandex».

> Методы — определяют, что нужно делать, когда строка найдена: заменить её или сообщить, где произошло совпадение.

> Флаги — кастомизируют работу метода (увеличивают возможности). Например, выставив флаг, можно найти все совпадения с регуляркой или только одно.

Таким образом: спецсимволы определяют, что искать; методы — что делать; а флаги — как делать.

## Методы

> Запутаться тут очень легко. Поэтому будем писать имена методов вместе с объектом, в который они записаны: String.match и RegExp.test.
  
### Методы строк.
Их вызывают как метод строки:

#### String.search
принимает на вход регулярное выражение и возвращает индекс символа, на котором произошло совпадение:

    const regex = /\d{3,}/i;
    const string = '12! равен 479001600';

    string.search(regex); // 10 
    Метод String.search 
    
  не работает с глобальным поиском

#### String.split

можно передать на вход символ в ковычках или регулярное выражение.
Тогда на выходе мы получим массив элементов, которые находили между строчками, найденными нашей регуляркой:

#### String.replace
ищет в тексте совпадение с регуляркой из первого аргумента, составляет какую-то новую строку из полученной во втором аргументе и возвращает её нам.

### Методы регулярных выражений.
Их вызывают как метод регулярки:

#### RegExp.exec

похож на String.match. Если нет флага g вернут одинаковый результат:

если установить флаг g он вернёт первое совпадение, а затем — запишет в свойство lastIndex регулярного выражения номер символа в тексте, на котором это совпадение произошло.
Если запустить метод RegExp.exec снова, он будет искать с того символа, на котором остановился

RegExp.exec обновляет свойство lastIndex после каждого вызова.

    const str = `Идёт без проволочек
    И тает ночь, пока
    Над спящим миром лётчик
    Уходит в облака.`;
    let regex = /.+/g;

    regex.exec(str); // ["Идёт без проволочек"]
    regex.exec(str); // ["И тает ночь, пока"]
    regex.exec(str); // ["Над спящим миром лётчик"]
    regex.exec(str); // ["Уходит в облака."] 


#### RegExp.test
Он вызывается на регулярном выражении, а строку принимает на вход. Результат работы метода — булево значение. Если совпадение найти удалось, RegExp.test вернёт true

    const regex = /\w+@\w+\.\w+/; // шаблон для поиска email
    const str = 'Stas Basov: stasbasov@yandex.ru';

    regex.test(str); // true 

тоже обладает памятью — как и RegExp.exec. Если передать ему регулярное выражение с флагом g

## Флаги

Флаг — символ, который стоит в регулярном выражении в самом конце (после слеша) и задаёт настройки поиска. Всего их шесть: g, i, m, u, y, s

Самые популярные
### g
будем искать все совпадения, а не только первое

    const regex = /с/;
    const regexGlobal = /с/g;
    const word = 'искусство';

    word.match(regex); // [ "с" ]
    word.match(regexGlobal); // [ "с", "с", "с" ]; 

### i
поиск не будет различать строчных и прописных букв

    const str = 'Вильгельм Конрад Рентген стал лауреатом Нобелевской премии в 1901 году.'

    const regex = /рентген/;
    const regexIgnore = /рентген/i;

    str.match(regex); // null
    str.match(regexIgnore); // [ "Рентген" ] 

### m
говорит движку, чтобы тот воспринимал каждый перенос как конец одной строки и начало другой.

сработает, только если мы используем определённые спецсимволы

! далее редкоиспользуемые

### u
можно искать символы по их номеру в Юникоде.

    const str = '& — это амперсанд. Его номер в таблице Юникод: 26';
    const regex = /\u{26}/; // здесь флаг u не установлен
    const regexUnicode = /\u{26}/u; // а здесь — установлен

    str.match(regex); // null
    str.match(regexUnicode); // ["&"] 

### y
провери, есть ли искомая строка в строго определённом месте текста.

! Работает так: вы включаете флаг y при составлении регулярного выражения. А затем записываете в свойство lastIndex этого регулярного выражения номер символа, с которого нужно проверять ! 

    const fuelUp = 'заправляемся, потом платим';
    let regex = /платим/y;

    regex.lastIndex = 0; 
    fuelUp.match(regex); 
    // null. Первое слово «заправляемся», а не «платим»

## Спецсимволы и их обратные классы

[полный перечень <-](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/RegExp)

 ### .
 (точка) Заменяет любой символ кроме переноса строки, может быть сколко угодно точек
 ### =
 после знака равно указать часть выражения ...
 ### \ 
  экранирует спецсимволы
 ### \w
  любая цифра, латинская буква или нижнее подчёркивание [обратный класс \W]
 ### \d
  любая цифра [обратный класс \D]
 ### \s
  ищет «пустоты» в тексте: пробелы (в том числе неразрывные), переносы строк и табуляции. [обратный класс \S]
 ### \b
  означает границу слова [обратный класс \B]

(любая нелатинская буква прочитывается движком как отдельное слово. Поэтому с кириллицей спецсимвол \b не работает.)

### Наборы и диапазоны

Чтобы создать набор, нужно перечислить подходящие символы в квадратных скобках:

    const str = '14/03/2018';
    const regex = /\d\d\W0[345]\W2018/g; // этот шаблон ищет все дни весны

    str.match(regex);

Диапазон — часть набора. Это два символа, разделённых дефисом.

    const str = '20/04/2019';
    const regex = /\d\d\W0[1-6]\W2019/g; // этот шаблон ищет все дни первого полугодия

    str.match(regex); // [ "20/04/2019" ] 

Кириллица

    const regex = /[\wа-я\sё]/gi;

    /* Ищем всю латиницу и всю кириллицу, все пробелы,
    а от знаков препинания избавляемся. */

    > чтобы не терять «ё», дописывайте её в набор:

### Исключающие наборы и диапазоны 

Чтобы сделать набор или диапазон исключающим, перед ним нужно поставить «шляпку» ^ (карет):

    const str = 'Оценки за четверть: 2 3 3 5 2 4 2 3 5';
    const regex = /[^1-3]/g;

    str.match(regex).join(''); // "Оценки за четверть:    5  4   5"

    // картина стала получше, но большие пустоты выдают обман 

## Квантификаторы

позволяют искать любое количество повторов

### + 
От одного до бесконечности повторений

### *
От нуля до бесконечности повторений

### ?
Необязательный символ

### {}
Контроль повторов
можно указать диапазон, например {2,5} от 2х до 5ти повторений

>Пример

    const regionCode = /\d{3}/;
    const    phoneNumber = 'Мой номер телефона: +7(999)123-12-21';

    phoneNumber.match(regionCode); // [ "999" ]

## Начало и конец строки

По умолчанию весь текст — одна строка, у которой есть один конец и одно начало.

Такое поведение движка можно изменить, поставив флаг m. Флаг m говорит движку, чтобы тот воспринимал каждый перенос как конец одной строки и начало другой.

Чтобы написать многострочный текст, перенос можно поставить комбинацией символов \n или пользоваться обычными переносами в шаблонных строках:

### начало строки обозначают шляпкой ^.
### конец — знаком доллара $.

## Многострочные тексты

Чтобы написать многострочный текст, перенос можно поставить комбинацией символов \n или пользоваться обычными переносами в шаблонных строках:

